const req = require("express/lib/request")

//how to create API
use async await 
-import shcema in the function
const user = await User.create({reg.body})

//the way to check the error
const {name, email, password} = req.body;
if(!name || !email || !password)  {
    throw new Error("please provide name, email, password")
}

***do not store password to the DB as a string***
how to harshing password use bcript.js random bytes
import bcript.js

const salt = await bcript.genSalt(10)
const hashedPassword = await bcript.hash(password,salt)
const tempUser = {name, email, password: hashedPassword}

const user = await User.create({...tempUser})

//mongoose middleware
import bcript to model

UserSchema.pre("save", async function(next) {
    const salt = await bcript.genSalt(10)
this.password = await bcript.hash(this.password,salt)
next()
})

//jwt
const user = await User.create({...req.body})
const token = jwt.sign({userId: user._id, name: user.name})
res.status(200).json({user:{name: user.name}, token}) // how to acess name

//how to genrate name in shcema
UserSchema.methods.getName = function() {
    return this.name
}

//invoke user.getNsame() instead of user.name
res.status(200).json({user:{name: user.getName()}, token}) // how to acess name

//also we can set jwt in model
UserSchema.methods.createJWT = function () {
  return jwt.sign({userId: this._id, name:this.anme }, "jwtsecret", {expiresIn: "30d"})
}

//back to auth
const user = await User.create({...req.body})
const token = user.createJWT()
res.status(200).json({user:{name: user.name}, token})

//we can get token from allkeygenerator website

//how to check the user exist
const { email, password } = req.body;

  if (!email || !password) {
    throw new BadRequestError("Please provide email and password");
  }
  
  const user = await User.findOne();

  if (!user) {
    throw new UnauthenticatedError("Invalid credential");
  }

  const token = user.createJWT();
  res.status(StatusCodes.OK).json({ user: { name: user.name }, token });

//How to compare the password
 UserSchema.methods.comparePassword = async function (cadidatePassword) {
  const isMatch = await bcript.compare(cadidatePassword, this.password);
  return isMatch;
};

//set the auth middleware in authentication.js do not forget to export the auth and invoke next
const auth = async (req, res, next) => {
  const authHeaders = req.headers.authorization;

  if (!authHeaders || !authHeaders.startsWith("Bearer")) {
    throw new UnauthenticatedError("Authenticaiton invalid");
  }

  const token = authHeaders.split(" ")[1];

  try {
    const payload = jwt.verify(token, process.env.JWT_SECRET);
    req.user = { userId: payload.userId, name: payload.name };
  } catch (error) {
    throw new UnauthenticatedError("Authenticaition invalid");
  }
};

//use auth for routes middleware
app.use("/api/v1/jobs", authenticateUser,jobRouter);

//set the jobs model
-create job Schema do not forget to put createdBy to refer to the file that asscociate with
createdBy: {
      type: mongoose.Types.ObjectId,
      ref: "User",
      require: [true, "please provide user"],
    },
  },
  { timeStamps: true }

  -go to the controller import jobs Schema 

  -then create jobs
  const createJobs = async (req, res) => {
  req.body.createdBy = req.user.userId;
  const job = await Jobs.create(req.body);
  res.status(StatusCodes.CREATED).json({ job });
};

//get all jobs
const jobs = await Jobs.find({createdBy: req.user.userID}).sort("createdAt")
res.status(ok).json({jobs})

//get a job
const getJob = async (req, res) => {
  const {
    user: { userId },
    params: { id: jobId },
  } = req;

  const job = await Jobs.findOne({
    _id: jobId,
    createdBy: userId,
  });

  //update jobs
  const updateJobs = async (req, res) => {
  const {
    body: { company, position },
    user: { userId },
    params: { id: jobId },
  } = req;

  if (company === "" || position === "") {
    throw new BadRequestError("Company or position cannot be emptied");
  }

  const job = await Jobs.findByIdAndUpdate(
    { _id: jobId, createdBy: userId },
    req.body,
    { new: true, runValidators: true }
  );

  if (!job) {
    throw new NotFoundError(`No job with id ${job}`);
  }
  res.status(StatusCodes.OK).json({ job });
};

//delete job
const deleteJobs = async (req, res) => {
  const {
    user: { userId },
    params: { id: jobId },
  } = req;

  const job = await Jobs.findByIdAndDelete({ _id: jobId, createdBy: userId });

  if (!job) {
    throw new NotFoundError(`No job with id ${job}`);
  }
  res.status(StatusCodes.OK).send();
};

//handle duplicate 
const { CustomAPIError } = require("../errors");
const { StatusCodes } = require("http-status-codes");

const errorHandlerMiddleware = (err, req, res, next) => {
  let CustomError = {
    //set default
    StatusCode: err.StatusCode || StatusCodes.INTERNAL_SERVER_ERROR,
    smg: err.message || "Something went wrong try again later",
  };

  if (err instanceof CustomAPIError) {
    return res.status(err.statusCode).json({ msg: err.message });
  }

  if (err.code && err.code === 11000) {
   CustomError.smg = `Duplicate value entered for ${Object.keys(
      err.keyValue
    )} field, please choose another value`;
    CustomError.StatusCode = 400;
  }
  /*  return res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({ err }) */
  return res.status(CustomError.StatusCode).json({ smg: CustomError.smg });
};

module.exports = errorHandlerMiddleware;